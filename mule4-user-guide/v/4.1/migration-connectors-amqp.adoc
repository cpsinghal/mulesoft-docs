// authors: Gonzalez
= Migrating to the AMQP Connector

// Explain generally how and why things changed between Mule 3 and Mule 4.
The AMQP transport was completely reshaped and evolved away from the Mule 3 transport model into an operation based connector with a simplified UX and fully DataSense enabled Message information. 
This means not only that using AMQP now provides the same experience regarding connection and configuration that any other connector, but also that producing and consuming messages is simpler based on the structured Message information.

What's covered in this section:

* <<Configuring The Connector>>
* <<Connecting To A Broker>>
* <<Sending Messages>>
* <<Listening For New Messages>>
* <<Consuming Messages>>
* <<Handling Topic Subscriptions>>
* <<Responding To Incomming Messages>>
* <<Doing Request-Reply>>
* <<Using Transactions>>

[[Configuring The Connector]]
== Configuring The Connector

Moving from a 3.x transport configuration to a AMQP Connector configuration in Mule 4 implies basically using most of the same  parameters, but declaring them in a more cohesive way. Some parameters changed in Mule 4 AMQP Connector.
This means for example that parameters that are used for consuming Messages are declared in a 'consumer-config' group, while general authentication parameters are configured in the General group. Also, a separation has been made between the parameters that affect the behaviour of the connector (present in the config) from those that affect only how the connection is established (present at connection level):

.Mule 3 Example: Configuring The Connector
[source, xml, linenums]
----
<amqp:connector name="AMQP_Config"
     fallbackAddresses="192.168.0.1,192.168.0.2"
     virtualHost="/"
     username="guest"
     password="guest"
	 deliveryMode="TRANSIENT"
	 priority="1"
	 ackMode="AUTO"
	 activeDeclarationsOnly="false"
	 mandatory="false"
	 immediate="false"
	 prefetchSize="16"
	 prefetchCount="16"
	 noLocal="false"
	 exclusiveConsumers="false"
	 requestBrokerConfirms="false"
	 numberOfChannels="10"
	  />
----

This same configuration is achieved in Mule 4 setting the same parameters in the context where they actually apply:

.Mule 4 Example: Configuring The Connector
[source, xml, linenums]
----
<amqp:config name="AMQP_Config">
	<amqp:connection host="localhost" port="5672"
		virtualHost="/" username="guest" password="guest" />
	<amqp:consumer-config numberOfConsumers="10" exclusiveConsumers="false" noLocal="false" ackMode="AUTO"/>
	<amqp:publisher-config requestBrokerConfirms="false" mandatory="false" immediate="false" priority="1" deliveryMode="TRANSIENT"/>
	<amqp:quality-of-service prefetchSize="16" prefetchCount="16" />
</amqp:config>
----

Notice that `fallbackAddresses` is not supported anymore.


[[Sending Messages]]
== Sending Messages

With the new Mule 4 approach, the AMQP 'publish' operation relies only on its input parameters to completely build the AMQP Message to be published.

For example, if we wanted to send a high priority AMQP Message with only a part of the payload in the body, and associate that Message to a group, we'll need to:
<1>) Use `transform` to set the payload to what the Message body is expected to be.
<2>) Convert the resulting stream into a String to send it as a text message.
<3>) Set an AMQP property with `priority` as key to set the AMQP Message Priority.

.Mule 3 Example: Sending a prioritized Message as part of a Group
[source, xml, linenums]
----
<flow name="AmqpTransportOutbound">
    <http:listener config-ref="HTTP_Listener_Configuration" path="/orders"/>
    <dw:transform-message> // <1>
        <dw:set-payload><![CDATA[%dw 1.0
%output application/json
---
{
order_id: payload.id,
supplier: payload.warehouse
}]]></dw:set-payload>
    </dw:transform-message>
    <object-to-string-transformer/> <2>
    <amqp:outbound-endpoint exchangeName="testExchange" connector-ref="AMQP_Conector" >
      <message-properties-transformer scope="outbound">
          <add-message-property key="priority" value="9"/> // <3>
      </message-properties-transformer>
    </amqp:outbound-endpoint>
</flow>
----

The same results can be achived in Mule 4 using the AMQP Connector with the following configuration:

.Mule 4 Example: Sending a prioritized Message as part of a Group
[source, xml, linenums]
----
<flow name="AMQPConnectorPublish">
		<http:listener config-ref="HTTP_Listener_config" path="/orders"/>
		// <2>
		<amqp:publish config-ref="AMQP_Config" exchangeName="targetExchange> 
			<amqp:message> // <1>
				<amqp:body>#[output application/json --- 
        {
          order_id: payload.id,
          supplier: payload.warehouse
        }]</amqp:body>
        			<amqp:properties priority="3"/> // <3>
			</amqp:message>
		</amqp:publish>
	</flow>
----

Differences to be noted:

1) There's no need of the `transform` component, since the `body` of the Message is created inline, thus the payload remains unmodified.
2) The `object-to-string` transformer was also removed, since the Connector can handle automatically the transformation output.
3) Priority is set as a property in the AmqpMessage operation and doesn't rely on the user knowing the exact key.

As a summary, when publishing a Message in 3.x with the AMQP transport, we relied on the AmqpMessage payload, and outbound properties to configure the creation of the AMQP Message, which meant a deeper knowledge of how the transport worked. In 4.x, the AMQP Connector exposes every configurable element as a parameter in the scope were it belongs, thus exposing all the AMQP functionality in a clearer way.

[[Listening For New Messages]]
=== Listening For New Messages

The AMQP transport `inbound-endpoint` allows you to wait for new Messages on a given topic or queue. The output of this listener will contain the body of the message in the payload, and all the AMQP headers and properties as `inboundProperties`.

.Mule 3 Example: Listening For Messages
[source, xml, linenums]
----
<flow name="AMQPTransportInbound">
  <amqp:inbound-endpoint connector-ref="AMQP_Connector" queueName="in" />
  <dw:transform-message> // <2>
      <dw:set-payload><![CDATA[%dw 1.0
        %output application/json
        ---
        {
        items: payload,
        costumer: message.inboundProperties.'costumer_id',
        type: message.inboundProperties.'JMSType'
        }]]></dw:set-payload>
  </dw:transform-message>
  <object-to-string-transformer/>  // <3>
  <amqp:outbound-endpoint exchangeName="v2/prime/orders" connector-ref="AMQP_Connector"/>  // <4>
</flow>
----

In this case, we are listening for Messages and then adapting them to the new format required:

1) Transform the MuleMessage using the metadata contained in the inboundProperties so the payload matches the new JSON format we need for the new API.
2) Convert the transformed payload to a JSON String.
3) Publish the payload to the proxied exchange.

Implementing the same in Mule 4 looks like this:

.Mule 4 Example: Listening For Messages
[source, xml, linenums]
----
<flow name="AMQPConnectorPublish">
  <amqp:listener config-ref="AMQP_Config" queueName="in" /> // <1>
  <amqp:publish config-ref="AMQP_Config" exchangeName="v2/prime/orders"> // <2>
    <jms:message>
      <amqp:body>#[output application/json ---
      {
        items: payload,
        costumer: attributes.properties.userProperties.costumer_id, // <3>
        type: attributes.headers.type
      }]</amqp:body>
    </amqp:message>
  </amqp:publish>
</flow>
----

Now, the flow has fewer components and is not required to modify the Message payload to publish with a different format:

<1> Listening with a filter is done configuring the 'selector' in the listener.
<2> Definition of the new message is done inline, so it only creates the JSON for the new Message body.
<3> We use the message 'attributes' POJO instead of the 'inboundProperties', which now differentiate the 'headers' of the AMQP Messsage from the 'properties'.


[[Consuming Messages]]
=== Consuming Messages

Consuming Messages mid-flow from a given destination was not supported by Mule's 3 AMQP transport, and the way to go was also adding the 'Mule Requester Module' to your application, which would then handle the mid-flow message consume.

So, for example, if you wanted to expose your AMQP Queue behind a new REST API, your application would be similar to this:

.Mule 3 Example: Consuming Messages Mid-Flow
[source, xml, linenums]
----
<mulerequester:config name="Mule_Requester"/>
<jms:activemq-connector name="Active_MQ" brokerURL="tcp://localhost:61616" specification="1.1"/>

<flow name="ordersFromJMS">
  <http:inbound-endpoint exchange-pattern="request-response" path="orders" host="localhost" port="8081"/>
  <mulerequester:request config-ref="Mule_Requester" 
                         resource="jms://Orders?selector=shipped%3D'#[message.inboundProperties.'shipped']'"/>
  <logger level="INFO" message="CorrelationId: #[message.inboundProperties.'JMSCorrelationId']"/>
</flow>
----

Some things to notice here are:

* All metadata regarding JMS Message is completely lost, so logging the CorrelationId relies on you knowing the syntax for obtaining the Header. 
* Dynamic filterying by 'selector' has to be done in the 'resource' url of the requester, so multiple arguments end up with an error prone configuration.
* We need both the JMS and Mule Requester configurations.

Mule 4 comes out of the box with the capability of consuming messages mid-flow by using thr 'consume' operation. This operation is very similar to the Listener we saw before, with the difference that it can be used anywhere in the flow:

.Mule 4 Example:  Consuming Messages Mid-Flow
[source, xml, linenums]
----
<flow name="ordersFromJMS">
  <http:listener config-ref="HTTP_Listener_config" path="/orders"/>
  <jms:consume destination="Orders" selector=#['shipped=' ++ attributes.queryParams.shipped]/>
  <logger level="INFO" message="#['CorrelationId: ' ++ attributes.headers.correlationId]"/>
</flow>
----

Now we only needed a the JMS Connector, configured the 'consume' operation with the 'selector' parameter using the metadata from the listener, and also were able to log the correlationId with metadata support in the Message attributes.


[[Handling Topic Subscriptions]]
=== Handling Topic Subscriptions

Topics used as inbound endpoints in 3.x allowed the user to configure if the subscription to the Topic had to be done as a `durable` subscription or not. There were different ways of doing so, and it had the issue of exposing the `durable` configuration for `queues` too, which made no sense.

A Topic subscription in 3.x would look like this:

.Mule 3 Example: Topic Subscriptions
[source, xml, linenums]
----
<jms:inbound-endpoint connector-ref="Active_MQ" topic="trackedEvents" durable="true" durableName="inboundEvents_1"/>
----

For Mule 4, the subscription mechanism was reviewed, leaving the option of subscriptions scoped down to Topics only, and adding more functionality thanks to the support of JMS 2.0.

Same example as before, but in 4.x will be:

.Mule 4 Example: Topic Subscriptions
[source, xml, linenums]
----
<jms:listener config-ref="JMS_Config" destination="trackedEvents">
    <jms:consumer-type>
        <jms:topic-consumer durable="true" subscriptionName="inboundEvents_1"/>
    </jms:consumer-type>
</jms:listener>
----

But in this case, the `topic-consumer` configuration allows us to also set a `shared` subscription (only if using a JMS 2.0 Connection) that allows the processing of messages from at topic subscription by multiple threads, connections or JVMs:

.Mule 4 Example: Topic Subscriptions
[source, xml, linenums]
----
<jms:listener config-ref="JMS_Config" destination="trackedEvents">
    <jms:consumer-type>
        <jms:topic-consumer durable="true" shared="true" subscriptionName="inboundEvents_1"/>
    </jms:consumer-type>
</jms:listener>
----

[[Responding To Incomming Messages]]
== Responding To Incomming Messages

When the listener for new JMS Messages receives a Message with the 'JMSReplyTo' header configured, then it is expected that a response is emitted to the reply destination once the processing of the Message is completed.

For Mule 3, this means configuring the transport with `exchange-pattern="request-response"``, where the result of the flow will automatically become the payload of the response. Headers of the response Message were configured using the `outbound-properties`, while the body of the Message was taken from the `payload` at the end of the Flow.

.Mule 3 Example: Responding To Incomming Messages
[source, xml, linenums]
----
<flow name="jmsBridge">
  <jms:inbound-endpoint queue="storage" exchange-pattern="request-response" connector-ref="PublicAMQ">
    <message-properties-transformer scope="outbound">
      <add-message-property key="timeToLive" value="2000"/>
      <add-message-property key="timeToLive" value="2000"/>
    </message-properties-transformer>
  </jms:inbound-endpoint>
  <http:request config-ref="HTTP_Request_Configuration" path="/storage" method="POST"/>
  <set-payload value="BRIDGED">
</flow>
----

Mule 4 instead allows you to configure all the parameters associated to the response, directly inline as a part of the `listener` component, leaving behind the need of a transformation when reaching the end of the flow.

.Mule 4 Example: Responding To Incomming Messages
[source, xml, linenums]
----
<flow name="jmsBridge">
  <jms:listener config-ref="config" destination="storage">
    <jms:response timeToLive="2" timeToLiveUnit="SECONDS">
        <jms:body>#['BRIDGED']</jms:body>
    </jms:response>
  </jms:listener>
  <http:request config-ref="HTTP_Request_Configuration" path="/storage" method="POST">
</flow>
----

[[Doing Request-Reply]]
== Doing Request-Reply

JMS allows you to use the `JMSReplyTo` header to perform a synchronous communication. This can be done either with a temporary destination that is created on the fly by the client, or using an already existing destination.

=== Request Reply With Temporary Destinations

In Mule 3, for the first case where the reply destination is a temporary queue that will be discarded once the message arrives, we have the "request-response" exchange-pattern in the outbound endpoint:

.Mule 3 Example: Doing Request-Reply With Temporary Reply Destination
[source, xml, linenums]
----
<flow name="jmsRequestReplyTemporaryDestination">
  <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8080" path="invoices"/>
  <dw:transform-message>
      <dw:set-payload><![CDATA[%dw 1.0
        %output application/xml
        ---
        {
        data: payload,
        costumer: message.inboundProperties."http.query.params".costumer_id
        }]]></dw:set-payload>
  </dw:transform-message>
  <object-to-string-transformer/> 
  <jms:outbound-endpoint exchange-pattern="request-response" queue="invoiceProcessor" connector-ref="Active_MQ"/>
  <logger level="INFO" message="Status: #[payload]">
</flow>
----

Instead, in Mule 4 you have a brand new operation called `publish-consume` which aims to solve this specific use case:

.Mule 4 Example: Doing Request-Reply With Temporary Reply Destination
[source, xml, linenums]
----
<flow name="jmsRequestReplyTemporaryDestination">
  <http:listener config-ref="HTTP_Listener_config" path="/invoices"/>
  <jms:publish-consume config-ref="JMS_Config" destination="invoiceProcessor">
    <jms:message>
      <jms:body>#[output application/xml ---
      {
        data: payload,
        costumer: attributes.queryParams.costumer_id
      }]</jms:body>
    </jms:message>
  </jms:publish-consume>
  <logger level="INFO" message="#['Status: ' ++ payload]">
</flow>
----

You may see that, again, the building of the Message is donde inline of the operation, in the `message` element, and any transformation or configuration that affects the outgoing Message will be done as part of that element.


=== Request Reply With Explicit Destinations

Doing a request-reply with an explicit `reply-to` destination was a little bit more tricky in 3.x, since a new component was required, the `requet-reply` Scope:

.Mule 3 Example: Doing Request-Reply With Explicit Reply Destination
[source, xml, linenums]
----
<flow name="JMS-request-reply">
  <jms:inbound-endpoint queue="invoices" exchange-pattern="request-response" connector-ref="Active_MQ"/>
  <dw:transform-message>
      <dw:set-payload><![CDATA[%dw 1.0
        %output application/xml
        ---
        {
        data: payload,
        costumer: message.inboundProperties."http.query.params".costumer_id
        }]]></dw:set-payload>
  </dw:transform-message>
  <object-to-string-transformer/> 
  <request-reply> // <1>
    <jms:outbound-endpoint connector-ref="Active_MQ" exchange-pattern="one-way" queue="invoiceProcessor"/>
    <jms:inbound-endpoint connector-ref="Active_MQ" exchange-pattern="one-way" topic="processedInvoiceEvents"/>
  </request-reply>
  <logger level="INFO" message="#['Status: ' ++ payload]">
</flow>
----

This scope (1) allowed you to set an inbound and outbound transport to do the request-reply pattern. This way, it would inject the `JMSReplyTo` header automatically in the outgoing Message and then started listening in the inbound endpoint

For the case of Mule's 4 JMS Connector with the new `publish-consume` operation, it requires you to do almost no changes to the flow. If you want an specific destination for the reply to be sent, just configure the `reply-to` header in the Message builder directly, as you would in any other case of either a publish or a response:

.Mule 4 Example: Doing Request-Reply With Temporary Reply Destination
[source, xml, linenums]
----
<flow name="jmsRequestReplyTemporaryDestination">
  <http:listener config-ref="HTTP_Listener_config" path="/invoices"/>
  <jms:publish-consume config-ref="JMS_Config" destination="invoiceProcessor">
    <jms:message>
      <jms:body>#[output application/xml ---
      {
        data: payload,
        costumer: attributes.queryParams.costumer_id
      }]</jms:body>
    </jms:message>
    <jms:reply-to destination="processedInvoiceEvents" destinationType="TOPIC"/> // <1>
  </jms:publish-consume>
  <logger level="INFO" message="#['Status: ' ++ payload]">
</flow>
----

In this example we set the reply destination header (<1>) to a well-known Topic, to ilustrate that a known destination may be used by others to do things like event tracking or post-processing triggers.

[[Using Transactions]]
== Using Transactions

Transactions support is quite similar in its configuration when moving from 3.x to 4.x, with the expected change from it being configured in the `inbound-endpoint` and `outbound-endpoint` to the normalized Mule 4 approach for operations transactions:

.Mule 3 Example: Using Transactions 
[source, xml, linenums]
----
<flow name="transactedJmsFlow">
    <jms:inbound-endpoint queue="${in}">
        <jms:transaction action="ALWAYS_BEGIN" /> //<1> 
    </jms:inbound-endpoint>
    <set-variable variableName="originalPayload" value="#[payload]"/> //<2> 
    <dw:transform-message> //<3>
        <dw:set-payload><![CDATA[%dw 1.0
          %output application/xml
          ---
          payload
          ]]></dw:set-payload>
    </dw:transform-message>
    <object-to-string-transformer/>
    <jms:outbound-endpoint queue="${out}"> //<4>
        <jms:transaction action="ALWAYS_JOIN"/>
    </jms:outbound-endpoint>
    <default-exception-strategy>
        <commit-transaction exception-pattern="*"/> //<5>
        <set-payload value="#[flowVars.originalPayload]"/> //<6>
        <jms:outbound-endpoint queue="dead.letter"> //<7>
            <jms:transaction action="JOIN_IF_POSSIBLE"/>
        </jms:outbound-endpoint>
    </default-exception-strategy>
</flow>
----

Things to note are:

<1> Transaction is initiated by the inbound endpoint with `ALWAYS_BEGIN`
<2> We make sure not to loose the original payload
<3> Payload is transformed so it can be sent through the outbound endpoint
<4> The outbound endpoint is configured to `ALWAYS_JOIN`
<5> We set up the exception strategy to catch all exceptions
<6> Original payload is restored so the original message is published to the dead.letter
<7> Finally we send the original message to the dead.letter attempting to join to the current transaction.


Same scenarion can be implemented in Mule 4 with the following approach:

.Mule 4 Example: Using Transactions 
[source, xml, linenums]
----
<flow name="transactedJmsFlow">
    <jms:listener config-ref="JMS_Config" destination="${in}" transactionalAction="ALWAYS_BEGIN"/> //<1>
    <jms:publish config-ref="JMS_Config" destination="${out}" transactionalAction="ALWAYS_JOIN"> //<2>
        <jms:message>
            <jms:body>#[output application/xml --- payload</jms:body>
        </jms:message>
    </jms:publish>
    <error-handler>
        <on-error-continue type="ANY"> //<3>
          <jms:publish config-ref="JMS_Config" destination="dead.letter" transactionalAction="JOIN_IF_POSSIBLE"/> //<4>
        </on-error-continue>
    </error-handler>
</flow>
----

<1> Transaction is initiated by the `listener` with `ALWAYS_BEGIN`
<2> Publishing of the payload in XML format is done by the `publish` operation without modifying the current payload, also joining the transaction with `ALWAYS_JOIN`
<3> An error handler that catches any error occurred is used to make sure the Message is not lost
<4> Since the current payload is still the original Message received, we just publish it to the dead.letter using the `JOIN_IF_POSSIBLE` transactional action

== See Also

link:migration-examples[Migration Examples]

link:migration-patterns[Migration Patterns]

// link:migration-components[Migrating Components]
